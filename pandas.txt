1. Series (almost similar with numpy array, but it allows indexing)
	ser1 = pd.Series(data=[10,20,30],index=['A','B','C']) # data, index
	=> A    10
	   B	20
	   C	30
	# data not only numbers but also list, dictionary, string etc
	ser1['A'] = 10 # indexing
	* / + -


2. DataFrames
	# creating a dataframe
	df = pd.DataFrame(randn(5,4),['A','B','C','D','E'],['W','X','Y','Z']) # (values,row,column)
	# calling 'W' column
	df['W']
	# checking type of pandas series
	type(df['W']
	# checking type dataframe
	type(df)
	
	# calling multiple column
	df[['W','Z']] => column 'W' and 'Z" to choose 2 columns use 2 bracket
	# you can do some arithmetic with creating new column
	df['new'] = df['W'] + df['Y']
	
	# delete row and column (axis=1 for column,axis=0 for row, inplace for permanent)
	df.drop('W',axis=1,inplace=True) # 'A' is column
	df.drop('E',axis=0,inplace=True) # 'E' is index(row)
	# matrix shape (row x column)
	df.shape
	
	# calling rows
	df.loc['C'] => 'C' is the name of the index or identity
	df.iloc[2] => selecting row by numerical index position
	df.loc['B','Y'] => row B column Y
	df.loc[['A','B'],['X','Y']] => row A column B
	
	# using boolean 
	df > 0 => will result True or False
	df[boolean]
	df[df['W']>0]['Y']
	df[(df['W']>0) & (df['Y']>1)] # Don't use 'and' 'or'
	df[(df['W']>0) | (df['Y']>1)]
	
	# Set a column to be index
	df.set_index()
	
	# checking names of index
	df.index.names
	df.xs(['G1','1']) => another way to call data based on index data (not index name)


3. Missing Data
	df.dropna() # remove row if any NaN/missing point
	df.fillna() # input data to NaN value
	

4. Groupby
	df.groupby()
	df.groupby().mean()
	df.groupby().std()
	df.groupby().describe()
	df.groupby().describe().transpose()
	df.groupby(['The grouping column'])['The grouped column'].describe() # aggregate function
	# grouping with two features
	df.groupby(['W','X'])['Y'].mean() # 'W' first then 'X'
	# the features which was created as index turn to be column again with the most right position
	df = df.reset_index(level='X') # then
	df = df.reset_index(level='W')
	

5. Merging, Joining, Concatening
	# Mix in one data frame for axis = 0
	# shape should be the same
	pd.concat([df1,df2,df3]) 
	pd.concat([df1,df2,df3],axis=1)
	
	# Dictionaries also can be a data frame, key as column, value as data
	# merge a bit similar with full outer join
	pd.merge(df1,df2,how='inner',on='key')
	
	# join a bit similar with inner merge except your key is in index
	df1.join(df2)


6. Operations
	df['A'].unique()
	df['A'].nunique()
	df['A'].value_counts() # how many times data in a column show up
	df['A'].apply(func) # apply function to specific column
	df['A'].apply(len)
	df['A'].apply(lambda x: x*2)
	del df['A'] # permanently delete column
	df.columns
	df.index
	df.sort_values()
	df.isnull() # looking for NaN data
	df.pivot_table()


7. Data Input & Output
	df = pd.read_csv('text')
	df.to_csv() # df table become csv file
	pd.read_excel()
	df.to_excel()
	pd.read_html()
	engine = create_engine('sqlite:///:memory:')
	df.to_sql('my_table',engine)
	sql_df = pd.read_sql('my_table',con=engine)
		
	
